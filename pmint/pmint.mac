/**************************************
 *
 *  PMINT : Poor man's integrator
 *   http://www-sop.inria.fr/cafe/Manuel.Bronstein/pmint/
 *  This is a port of pmint Maple program by Manuel Bronstein to maxima.
 *
 *  Ported by Andrej Vodopivec (andrej.vodopivec@gmail.com).
 *
 *  Dimiter Prodanov:
 *  Support for Wright Omega function added
 *  Support for BesselJ and BesselI functions added 
 **************************************/

 /**************************************
 *
 *  Implementation of some utility functions I could not find in maxima
 *
 **************************************/
halfangles : false;
 
define_variable(verbose_level, 0, integer)$
pm_display(lev, [arg]) := if lev<=verbose_level then apply(print, arg)$

/* Control flags for special function integration */
define_variable(enable_erf_integration, false, boolean)$
/* define_variable(enable_gaussian_substitution, false, boolean)$ */

atom_parts(expr) :=
  if emptyp(expr) then {}
  else if numberp(expr) then {}
  else if atom(expr) then {expr}
  else if op(expr)="^" and numberp(part(expr, 2)) then atom_parts(part(expr, 1))
  else if member(op(expr), ["+", "-", "*", "/"]) then apply(union, map(atom_parts, args(expr)))
  else union({expr}, 
  lreduce(union, map(atom_parts, args(expr)))
 );

pmint_lcm(lst) := if not emptyp(lst) then 
		apply("*", lst)/lreduce('gcd, lst)
		else lst;


pmint_total_degree(expr) :=
  if numberp(expr) or floatnump(expr) or bfloatp(expr) then 0
  else if atom(expr) then 1
  else if member(op(expr), ["+", "-"]) then apply(max, map(pmint_total_degree, args(expr)))
  else if op(expr)="*" then apply("+", delete(0, map(pmint_total_degree, args(expr))))
  else if op(expr)="/" then pmint_total_degree(part(expr, 1)) - pmint_total_degree(part(expr, 1))
  else if op(expr)="^" and integerp(part(expr, 2)) then part(expr, 2)
  else 1$

pmint_allcoeffs(expr, vars) := block([v,e,i,eqs:[expr],eqs1:[], nn],
  for v in vars do (
    eqs1 : [],
    for e in eqs do (
	  nn: hipow(e,v),
	  if not numberp(nn) then return([]),
      for i:0 thru nn do (
        if ratcoeff(e,v,i)#0 then
          eqs1 : append(eqs1, [ratcoeff(e,v,i)]))),
    eqs : eqs1),
  eqs);


/**************************************
 *
 *   Change trig function to tan
 *   Make diff(tan(x),x)=1+tan(x)^2 and define diff(lambert_w(x), x)
 *
 **************************************/

define_variable(convert_trig_functions, true, boolean)$

matchdeclare([%x, %y], true)$
defrule(sin2tan, sin(%x), 2*tan(%x/2)/(tan(%x/2)^2+1))$
defrule(csc2tan, sin(%x), tan(%x/2)(tan(%x/2)^2+1)/(2*tan(%x/2)))$
defrule(cos2tan, cos(%x), (1-tan(%x/2)^2)/(1+tan(%x/2)^2))$
defrule(sec2tan, sec(%x), (1+tan(%x/2)^2)/(1-tan(%x/2)^2))$

convert_to_tan(expr) := ratsimp(apply1(ratsimp(expr), sin2tan, cos2tan, sec2tan, csc2tan))$

gradef(tan(x),  1+tan(x)^2)$
gradef(tanh(x), 1-tanh(x)^2)$

/*
Lambert W function
*/
gradef(lambert_w(x), lambert_w(x)/(x*(lambert_w(x)+1)))$
alias (W, lambert_w);
/*
Wright Omega function
*/
gradef(omega(x), omega(x)/(1+omega(x)))$

/* Workarounds for Gaussian and erf - only used when enabled */
gradef(ga(x), -2*x*ga(x))$
gradef(erf1(x), (2*ga(x))/sqrt(%pi))$
/*
* Workarounds for Bessel functions
*/

gradef(bessj(n, x),  x,  n*bessj(n, x)/x - bessj1(n, x)  );
gradef(bessj1(n, x), x,  bessj(n, x)-(n+1)*bessj1(n, x)/x );

gradef(bessy(n, x),  x,  n*bessy(n, x)/x - bessy1(n, x)  );
gradef(bessy1(n, x), x,  bessy(n, x)-(n+1)*bessy1(n, x)/x );

gradef(bessi(n, x),  x,  n*bessi(n, x)/x + bessi1(n, x)  );
gradef(bessi1(n, x), x,  bessi(n, x)-(n+1)*bessi1(n, x)/x );

gradef(bessk(n, x),  x,  n*bessk(n, x)/x + bessk1(n, x)  );
gradef(bessk1(n, x), x,  bessk(n, x)-(n+1)*bessk1(n, x)/x );

matchdeclare( %n, atom)$
defrule(bessj2b, bessel_j( %n, %x), bessj( %n, %x)) ;
defrule(b2bessj,  bessj( %n, %x), bessel_j( %n, %x)) ;

defrule(bessy2b, bessel_y( %n, %x), bessy( %n, %x)) ;
defrule(b2bessy,  bessy( %n, %x), bessel_y( %n, %x)) ;

defrule(bessi2b, bessel_i( %n, %x), bessi( %n, %x)) ;
defrule(b2bessi,  bessi( %n, %x), bessel_i( %n, %x)) ;

defrule(bessk2b, bessel_k( %n, %x), bessk( %n, %x)) ;
defrule(b2bessk,  bessk( %n, %x), bessel_k( %n, %x)) ;

defrule(bessj2b1, bessel_j( %n+1, %x), bessj1( %n, %x)) ;
defrule(b2bessj1,  bessj1( %n, %x), bessel_j( %n+1, %x)) ;

defrule(bessy2b1, bessel_y( %n+1, %x), bessy1( %n, %x)) ;
defrule(b2bessy1,  bessy1( %n, %x), bessel_y( %n+1, %x)) ;

defrule(bessi2b1, bessel_i( %n+1, %x), bessi1( %n, %x)) ;
defrule(b2bessi1,  bessi1( %n, %x), bessel_i( %n+1, %x)) ;

defrule(bessk2b1, bessel_k( %n+1, %x), bessk1( %n, %x)) ;
defrule(b2bessk1,  bessk1( %n, %x), bessel_k( %n+1, %x)) ;

convert_bess2b(expr):=apply1(expr, bessj2b, bessj2b1, bessy2b1, bessy2b, bessi2b, bessi2b1, bessk2b, bessk2b1);

convert_b2bess(expr):=apply1(expr, b2bessj, b2bessj1, b2bessy, b2bessy1, b2bessi, b2bessi1, b2bessk, b2bessk1 );

/*
polylogarithms

gradef(pli(n,x), 0, pli1(n,x)/x);

defrule(li2pli, li[%n] ( %x), pli( %n, %x)) ;
defrule(pli2li,  pli( %n, %x), li[%n]( %x)) ;
defrule(pli2li1,  pli1( %n, %x), li[%n-1]( %x)) ;

convert_li2p(expr):=apply1(expr, li2pli);
convert_p2li(expr):=apply1(expr, pli2li,pli2li1);
*/

/* Workarounds for Ei */
gradef(ei(x), dei(x));
gradef(dei(x), dei(x)-dei(x)/x );

defrule(log2atan, log( (%i+%x)/(%x-%i)), -2*%i*atan(%x)  );
defrule(log2atan1, %n*log((%x+%i)/(%x-%i)), -2*%n*%i*atan(%x)  );
defrule(log2atan2, log((%x+%i)^%n/(%x-%i)^%n), -2*%n*%i*atan(%x)  );

convert2atan(expr):=block([ret],
	apply1(logcontract(expr), log2atan, log2atan1, log2atan2)
);

matchdeclare([%m], atom);
defrule(tan2sin, tan(%m/2),  sin(%m)/(1+cos(%m)))$
convert_from_tan(expr):=ratsimp(apply1(expr, tan2sin))$


/**************************************
 *
 *   Special Darboux polynomials p (x):
 *   Def: Df(x) = p(x) * f(x)
 *   If the second parameter is false, only use it for log parts, otherwise use it
 *   for denominator too.
 *
 **************************************/

put(tan, [ lambda([u], 1+u^2), false], 'darboux_poly)$
put(tanh, [ lambda([u], 1-u^2), false], 'darboux_poly)$
put(lambert_w, [ lambda([u], u), true], 'darboux_poly)$
put(omega, [ lambda([u], u), true], 'darboux_poly)$
put(bessj, [ lambda([u], u), false], 'darboux_poly)$
put(bessj1, [ lambda([u], u), false], 'darboux_poly)$
put(bessy, [ lambda([u], u), false], 'darboux_poly)$
put(bessy1, [ lambda([u], u), false], 'darboux_poly)$
put(bessi, [ lambda([u], u), false], 'darboux_poly)$
put(bessi1, [ lambda([u], u), false], 'darboux_poly)$
put(bessk, [ lambda([u], u), false], 'darboux_poly)$
put(bessk1, [ lambda([u], u), false], 'darboux_poly)$
put(expintegral_ei, [ lambda([u], u), false], 'darboux_poly)$

/* Darboux polynomials for Gaussian/erf support */
put(ga, [ lambda([u], -2*u), true], 'darboux_poly)$
put(erf1, [ lambda([u], u), false], 'darboux_poly)$

/* Darboux polynomials for Ei support */
put(ei, [ lambda([u], u), false], 'darboux_poly)$
put(dei, [ lambda([u], u), false], 'darboux_poly)$


get_special_polys(f, l) :=
  if atom(f) or  listp(f) then 0
  else block([pol , sop:op(f)],
  	/*display(sop, f),*/
	if not symbolp(sop) and not listp(sop) and not sop="^" then sop:op(sop),
	pol:  get(sop, 'darboux_poly),
    if pol#false then
      [pol[1](subst(l,f)), pol[2]]
    else
      0)$

/**************************************
 *
 *   The algorithm
 *
 **************************************/

define_variable(%k1, %k1, any)$
define_variable(%k2, %k2, any)$

/**************************************
 *
 *  1) substitute all sub-expressions in expr and diff(expr, x) for new variables:
 *     expr = x*sin(x) -> [x=g1, sin(x)=g2, cos(x)=g3]
 *
 *  2) get derivation info:
 *       [[g1,g2,g3], [1,g3,-g2]]
 *     diff(expr, x) = ( diff(expr, g1)*1 + diff(expr,g2)*g3 + diff(expr,g3)*(-g2) ) / q
 *
 *  3) tries to integrate substitution
 *
 *  pmint tries to find the result in the form f/g + log(h) where f,g,h are polynomials
 *  in new variables
 *
 *************************************/

/*
wrapper around the algorithm allowing for simplification of the result
*/
pmints(intexp, [simpfun]):=block ([ret:nil ],
	if freeof('integrate, intexp ) then return(intexp), 
	sop:op(intexp),
	if sop="+" or sop="-" then  
		ret: map(lambda([u], pmints (u, simpfun)), intexp) 
 	elseif sop=nounify(integrate) then (
		ret:subst(nounify(integrate)= lambda ([u,v], 
				pmint(u,v)), intexp
		)
	),
	if not emptyp(simpfun) then (
		simpfun:flatten(simpfun),
		if not emptyp(simpfun) then (
			simpfun:simpfun[1],
			ret: apply(simpfun, [ret])
		)
	),
	ret
);

/* checks if the the expression contans Bessel functions*/
besselp(expr):=not (freeof(bessel_j, expr) and freeof(bessel_i, expr) and  freeof(bessel_y, expr) and  freeof(bessel_k, expr) );

/* checks if the the expression contans trigonometric functions*/
trigp(expr):=not (freeof(sin, expr) and freeof(cos, expr) and  freeof(tan, expr) and  freeof(cot, expr)
and  freeof(sec, expr) and  freeof(csc, expr));

pmint(expr, x) := block(
  [ff, si, si1, li, lin, lout, ld, q, d, l, vars, dx, ls, fint, lc, si0, bconvert:false, btrig:trigp(expr),  
  erfconvert:false, gshift:false, shifteq:[] ],

  /* 0) preproces expr */
  if convert_trig_functions then
    ff : convert_to_tan(expr)
  else
    ff : expr,
 
  if besselp(ff) then (
	ff: convert_bess2b(ff),
	bconvert:true
  ),
 
  ff : factor(ff),

  /* Conditional Gaussian/erf preprocessing - only if enabled */
  if enable_erf_integration and (gaussp(ff, x) or not freeof(erf, ff)) then block([%ng, %b, offset:0, scale:1, svar:x],
    ff : ga2exp(ff),
    ff : erf2e1(ff),
    ff : gaussubst(expand(ff), x),
	display(ff),
    /* global shift detection */
    ga2(ff),
    offset: ratcoef(%b, x, 0),
    scale: ratcoef(%b, x, 1),
    gshift: is (offset#0),
    if gshift=true and scale#0 then ( 
      ff:subst(x=svar-offset/scale, ff),
      ff:ratsimp(ff),
      display(ff),
      shifteq:x=x+ offset/scale
      ),
    erfconvert:true
  ),

  
  /* 1) substitute expressions */
  si0 : setify(listofvars(ff)),
  si0 : subset(si0, lambda([u], is(diff(u,x)#0))),
  si : subset(atom_parts(ff), lambda([u], is(diff(u,x)#0))),
  pm_display(1, 'atom_parts=si),
  si1 : apply(union, listify(map(atom_parts, map(lambda([u], diff(u,x)), si)))),
  si : union(subset(si1, lambda([u], is(diff(u,x)#0))), si),
  si : setdifference(si, si0),
  li : reverse(append(args(si0), args(si))),
  lin : makelist(d=gensym(), d, li),
  lout : makelist(rhs(d)=lhs(d), d, lin),
  pm_display(1, 'substitution=lin),

  /* 2) get derivation info */
  ld : map(lambda([u], diff(u,x)), li),
  ld : subst(lin, ld),
  q : pmint_lcm(makelist(denom(ratsimp(d)), d, ld)),
  l : makelist(ratsimp(q*d), d, ld),
  vars : map(lhs, lout),
  dx : [vars, l],
  pm_display(1, 'deriv_info=dx),

  /* 3) get special darboux polys */
  ls : makelist(get_special_polys(d, lin), d, li),
  ls : delete(0, ls),
  ls : map(args, ls),

  /* 4) integrate substitution */
  fint : subst(lout, pm_integrate(subst(lin, ff), dx, q, vars, ls)),
  
  
  if not(mapatom(fint)) and freeof( 'integrate, fint) then block([dfint : diff(fint, x), re ],
  
  pm_display(0, 'fint=fint),
  /* checking the solution */
  re:dfint-expr,

  if expand(re,0)#0 then (
	  if btrig then (re:trigrat(trigsimp(re)), print("Trigonometric simplification 1 " +re)),
	re:ratsimp(re),
	if re# 0 then (
		re:radcan(re),
		if re#0 then (
			re:ratsimp(dfint-ff),
			if re #0 then (
				if btrig then ( re:trigrat(trigsimp(re)), print("Trigonometric simplification 2 " +re)),
			if  radcan(re)#0 then (
				print("Solution check fails!"+ re),
				fint:'integrate(expr, x),
				return(fint)
	))))),
	if bconvert then
		fint: convert_b2bess(fint),

	if convert_trig_functions then (
		/*fint : convert2atan(fint),*/
		fint : convert_from_tan(fint)
	),
	/*display(fint),*/
    if erfconvert then (
      if gshift=true then
        fint:subst(shifteq, fint),
      fint : ga2exp(fint),
      fint : e12erf(fint)
    ),
	fint
  ) else
    'integrate(expr, x)
)$

/**************************************
 *
 * f    - substitution
 * d    - differential infos
 * q    - denominator of differentials
 * vars - variables in expression
 * ls   - special darboux polys
 *
 **************************************/

pm_integrate(f, d, q, vars, ls) := block(
  [splq, s, ff, df, spl, cden, dg, monomials, cand, lunk, sol, i, listarith:true ],

  pm_display(1, 'expr=f),

  /* guess the denominator */
  splq : split_factor(q, d),
  s : splq[1],
  for i thru length(ls) do
    if ls[i][2] then s : s*ls[i][1],
  ff : ratsimp(f),
  df : denom(ff),
  spl : split_factor(df, d),
  cden : s * spl[1] * deflation(spl[2], d),
  pm_display(1, 'denominator=cden),

  /* guess the degree of numerator */
  dg : 1 + pmint_total_degree(s) +  max(pmint_total_degree(num(ff)), pmint_total_degree(denom(ff))),
  monomials : args(enumerate_monoms(vars, dg)),
  lunk : makelist(%k1[i], i, 1, length(monomials)),
  pm_display(1, 'num_degree=dg),
  pm_display(1, 'monom_length=length(monomials)),

  /*
    candidate for the result is

       linear combinations of all mononials with degree <=dg
       -----------------------------------------------------  + log-parts
                             cden

    log-parts are added in try_integral
  */
  cand : (lunk . monomials) / cden,

  /* Add erf candidates when enabled */
  if enable_erf_integration then block([erf_candidates:[], erf_unks:[], orig, ga_arg, new_unk],
    for i:1 thru length(vars) do (
      orig : assoc(vars[i], lout),
      if not atom(orig) and op(orig) = 'ga then (
        ga_arg : part(orig, 1),
        new_unk : gensym(),
        erf_candidates : endcons(new_unk * erf1(ga_arg), erf_candidates),
        erf_unks : endcons(new_unk, erf_unks)
      )
    ),
    if length(erf_candidates) > 0 then (
      erf_candidates : subst(lin, erf_candidates),
      cand : cand + apply("+", erf_candidates),
      lunk : append(lunk, erf_unks)
    ),
    pm_display(1, 'erf_candidates=erf_candidates)
  ),
  
  
 sol : try_integral(f, d, q, vars, cand, lunk, spl[1], spl[2], splq[1], ls, true),
  if sol[1]=true then
    sol : try_integral(f, d, q, vars, cand, lunk, spl[1], spl[2], splq[1], ls, false),
  if sol[1]=true then
    'integrate(expr, x)
  else sol[2])$

/**************************************
 *
 *  try_integral adds the log parts to candidate and
 *  then solves f-diff(candidate,x)=0
 *
 *  f         - expression to be integrated
 *  d         - derivation info - used for total_derivation
 *  q         - denominator for total_defivation
 *  vars      - variables appearing in expression
 *  cand      - candidate form for the result - without log parts
 *  lunk      - %k1 added in pm_integrate
 *  l1,l2,l3  - factors
 *  ls        - special darboux polys
 *  real      - get candidates for log parts using gfactor?
 *
 **************************************/

try_integral(f, d, q, vars, cand, lunk, l1, l2, l3, ls, real) := block(
  [candlog, p, candidate, i, sol, candidate1, redund : [], eqs, eqs1,
    linsolvewarn:false, solve_inconsistent_error:false, listarith:true,
	 erf_subst_list:[], temp_vars_list:[], ga_subst_list:[], erf_terms, erf_arg, temp_erf_var],

  pm_display(1, ['ENTERING_TRY_INTEGRAL]),  
  
  /* Get log part - all factors can appear */
  candlog : append(pmint_factors(l1, real), pmint_factors(l2, real), pmint_factors(l3, real)),
  candlog : union(setify(candlog), setify(makelist(p[1], p, ls))),
  candlog : subset(candlog, lambda([u], not(constantp(u)))),
  candlog : listify(candlog),
  redund : makelist(%k2[i], i, 1, length(candlog)),
  if length(candlog)>0 then
    candidate : cand + redund . map(log, candlog)
  else
    candidate : cand,
  candidate1 : candidate,
  pm_display(1, 'log_part=candlog),

  /* Handle erf substitution when enabled */
  if enable_erf_integration and not freeof(erf1, candidate) then (
    erf_terms : subset(atom_parts(candidate),
                       lambda([u], not atom(u) and op(u) = 'erf1)),
    erf_terms : listify(erf_terms),

    for i:1 thru length(erf_terms) do (
      temp_erf_var : gensym("e"),
      erf_subst_list : append(erf_subst_list, [erf_terms[i] = temp_erf_var]),
      temp_vars_list : append(temp_vars_list, [temp_erf_var]),
      erf_arg : part(erf_terms[i], 1),
      ga_subst_list : append(ga_subst_list, [ga(erf_arg) = vars[1]])
    ),

    pm_display(1, 'erf_subst_list=erf_subst_list),
    pm_display(1, 'temp_vars_list=temp_vars_list)
  ),
  
  /* solve f-diff(candidate,x)=0 */
  candidate : expand(num(ratsimp(f-total_derivation(d[1], d[2], candidate)/q))),
  pm_display(1, 'candidate_before_subst=candidate),

  /* Apply erf substitutions if needed */
  if length(erf_subst_list) > 0 then (
    candidate : subst(erf_subst_list, candidate),
    for sub in ga_subst_list do
      candidate : subst(ratsimp(lhs(sub)) = rhs(sub), ratsimp(candidate)),
    pm_display(1, 'candidate_after_erf_subst=candidate),
    eqs : pmint_allcoeffs(candidate, append(vars, temp_vars_list))
  ) else (
    eqs : pmint_allcoeffs(candidate, vars)
  ),
  eqs : pmint_allcoeffs(candidate, vars),
  vars : append(listify(lunk), makelist(%k2[i], i, 1, length(candlog))),
  if errcatch(sol : linsolve(eqs, vars))=[] then return([true, []]),

  /* substitute solution into candidate */
  sol : subst(makelist(u=0, u, %rnum_list), sol),
  candidate1 : subst(sol, candidate1),
  candidate1 : subst(makelist(u=0, u, redund), candidate1),

  if sol=[] or sol=all then [true, []]
  else [false, subst(sol, candidate1)])$

/**************************************
 *
 * enumerates monomials in variables vars up to degree d.
 *
 *  ([x,y], 2) -> {1,x,x^2,y,y^2,x*y}
 *
 **************************************/

enumerate_monoms(vars, d) := block(
  [n, x, i, v, s, w],
  n : length(vars),
  if n = 0 then {1}
  else (
    x : vars[n],
    v : makelist(vars[i], i, 1, n-1),
    s : enumerate_monoms(v, d),
    for i:1 thru d do
    s : union(s, apply(set, makelist(x^i*w, w, listify(enumerate_monoms(v,d-i))))),
    s))$

/**************************************
 *
 * total derivative of expr in variables lv.
 * ld are the differentials of corresponding variables.
 *
 * (This is really the numerator of total_derivative.)
 *
 **************************************/

total_derivation(lv, ld, expr) := block([fp:0, i],
  for i:1 thru length(ld) do fp : fp+ld[i]*diff(expr, lv[i]),
  fp
)$

/**************************************
 *
 * split_factor and deflation extract from p things we want in the denominator
 *
 **************************************/

split_factor(p, d) := block(
  [si, x, c, q, spl, s, splh, ddd],
  si : subset(setify(listofvars(p)), lambda([u], is(expand(total_derivation(d[1], d[2], u))#0))),
  if length(si)=0 then return([1,p]),
  x : first(si),
  c : content(p, x), q : c[2], c : c[1],
  if c=p then return([1,p]),
  spl : split_factor(c, d),
  s : ratsimp( gcd(q,total_derivation(d[1], d[2], q))/gcd(q,diff(q,x)) ),
  if pmint_total_degree(s)=0 then return([first(spl), q*second(spl)]),
  splh : split_factor(ratsimp(q/s), d),
  [first(spl)*first(splh)*s, second(spl)*second(splh)]
)$

deflation(p, d) := block(
  [si, x, c, q],
  si : subset(setify(listofvars(p)), lambda([u], is(expand(total_derivation(d[1], d[2], u))#0))),
  if length(si)=0 then return(p),
  x : first(si),
  c : content(p, x), q : c[2], c : c[1],
  if c=p then return(p),
  deflation(c, d) * gcd(q, diff(q, x))
)$

/**************************************
 *
 * returns a list of factors of expr without multiplicities.
 * if real is false it uses gfactor.
 *
 **************************************/

pmint_factors(expr, real) := block([%cc%, ff],
  ff : expr * %cc%,
  if numberp(expr) or atom(expr) then return([expr]),
  if real=true then
    delete(%cc%, makelist(if not(atom(u)) and op(u)="^" then first(u) else u, u, args(factor(ff))))
  else
    delete(%cc%, makelist(if not(atom(u)) and op(u)="^" then first(u) else u, u, args(gfactor(ff))))
)$



/**************************************
 *
 * GAUSSIAN AND ERF SUPPORT FUNCTIONS
 * Added for erf/Gaussian integration
 * Only active when enable_erf_integration or enable_gaussian_substitution = true
 *
 **************************************/

/* Pattern matching declarations */
matchdeclare([%a, %b, %c, %rr], true)$
matchdeclare(%ng, freeof(ga))$
matchdeclare([%x, %n], atom)$
defmatch(sqker1, %rr*exp(%a*%x^2 + %b*%x + %c), %x)$
defmatch(ratexp1, %a*exp(%b))$
defmatch(ga1, %a*ga(%b))$
defmatch(ga2, %ng*ga(%b))$

defmatch(exp_erf_pattern, %rr*exp(%b*%x)*erf(%a*%x), %x)$
defmatch(exp_erf_pattern1, %rr*%x^%n*exp(%b*%x)*erf(%a*%x), %x)$

/* Detects if expression contains Gaussian kernels */
gaussp(expr, x):=block([%a, %b, %c, %rr, ret],
  if atom(expr) then return(false),
  if op(expr)="+" then 
    ret: apply("or", maplist( lambda([u], gaussp(u, x)), expr))
  else (
    ret:sqker1(expr, x),
    ret:is(ret#false) or not freeof(ga, expr)
  )
)$

/* Complete the square for quadratic expressions */
complete_square_cv(expr, t) := block([aa, bb, cc],
  if hipow(expr,t)=2 then (
    aa: ratcoef(expr, t, 2),
    bb: ratcoef(expr, t, 1),
    cc: ratcoef(expr, t, 0),
    /* [ D, F, K] */
    [ (cc - bb^2/(4*aa)), (t + bb/(2*aa))]
  ) else []
)$

/* Extract Gaussian kernel from exponential */
gaussian_exp_sq(expr,xx):=block([%a,%b,%c,%rr,sqexp],
  sqker1(expr,xx),[%a,%b,%c],
  append(complete_square_cv(%a*xx^2+%b*xx+%c,xx),[%rr])
)$

/* Sign function */
sgn(x):=block(
  if not atom(x) then (if op(x)="-" then -1) 
  else 
    if numberp(x) then if x<0 then -1 else 1 
  else 1
)$

/* Substitute Gaussian kernels with ga() function */
gaussubst(expr, xx) := block([gf, fr, fr1, result, %a, %b, %c, %rr, scale_factor, assume_pos:true],
	  if mapatom(expr) or freeof(xx, expr) then return(expr),
	  
	  if op(expr)="-" then 
	    return (-gaussubst(-expr, xx)),
	  
	  /* Handle sums */
	  if op(expr) = "+" then 
	    return(map(lambda([u], gaussubst(u, xx)), expr)),
	  
	  /* Handle products - recurse on each factor */
	  if op(expr) = "*" then
	    return(apply("*", map(lambda([u], gaussubst(u, xx)), args(expr)))),
	  
	  /* Handle powers and divisions */
	  if op(expr) = "/" then
	    return(gaussubst(num(expr), xx) / gaussubst(denom(expr), xx)),
	  
/*      
	  if op(expr) = "^" and not (part(expr,1) = %e) then
	    return(expr),
*/	  
	  /* Handle exponentials */
	 
      result: sqker1(expr, xx),  

	  result : gaussian_exp_sq(expr, xx),
	  
	  if emptyp(result) or length(result) < 3 then return(expr),
	  
	  [fr, gf, fr1] : result,
	  
	  /* For exp(-(a^2)*x^2 + ...), %a = -(a^2), so sqrt(-%a) = a */
	  scale_factor : sqrt(-%a),
	 
	  fr1 * exp(fr) * ga(scale_factor * gf)
	)$

/* Conversion functions */
declare(ga2exp, evfun)$
ga2exp(expr):=block([u], 
  subst(ga=lambda([u], exp(-u^2)), expr)
)$

declare(e12erf, evfun)$
e12erf(expr):=block([u], 
  subst(erf1=lambda([u], erf(u)), expr)
)$

declare(erf2e1, evfun)$
erf2e1(expr):=block([u], 
  subst(erf=lambda([u], erf1(u)), expr)
)$



/* Integration by parts wrapper for exp*erf patterns */
pmintibp(expr, x) := block([ff, ibp_result, %rr,%a,%b,%n,%x, b ],
  ff : expand(expr, 0),

  if exp_erf_pattern1(ff, x) # false then 
    if %n#0 then (
      display( ff/x^%n),
      ibp_result : try_exp_erf_ibp(ff/x^%n, x)
    ) else 
      ibp_result : try_exp_erf_ibp(ff, x),

    if ibp_result # false then (
      if %n#0 then (
        display(%b),
        b: -ratcoef(%b, x, 0),
        ibp_result:(-1)^%n*diff(ibp_result, b, %n),
        ibp_result:ga2exp(ibp_result)
      ),
      return(ibp_result)
    ),

  /* If no exp*erf pattern (or IBP declined), fall back to original pmint */
  pmint(expr, x)
)$

/* IBP handler in x, delegating the kernel to the original pmint */
try_exp_erf_ibp(expr, x) := block([result,  %b, %a, %rr, u, v, v_part, du_dx, kernel, b],
  result : exp_erf_pattern(expr, x),
  if result = false then return(result),
  display (result), 
  b: ratcoeff(%b, x,0),
  if b = 0 then return(false),
  display( b), 
  u : expr / ( exp(b*x)),     
  v : 1/b * exp(b*x),
  v_part : u * v,
  v_part : ratsimp(v_part),

  du_dx : diff(u, x),
  du_dx : ga2exp(du_dx),
  kernel : (v * du_dx),
  kernel: ratsimp(kernel),

  /* Delegate kernel integration to the original pmint */
  v_part - pmint(kernel, x)
)$

defmatch(erf2_exp_pattern, exp(%b*%x)*erf(%a*%x)^%n, %x)$

try_erf2_exp_ibp(expr, x) := block([result, %b, %a, %n, u, v, v_part, du_dx, kernel],
  result : erf2_exp_pattern(expr, x),
  if result = false or %b=0 then return(false),

  /* u = erf(%a*x)^2, dv = exp(%b*x) dx */
  u : erf(%a*x)^2,
  v : exp(%b*x)/%b,
  v_part : u * v,

  /* du = 2*erf(%a*x) * (2*%a/sqrt(%pi)) * exp(-(%a*x)^2) */
  du_dx : diff(u, x),

  kernel : v * du_dx,
  kernel : ratsimp(expand(kernel)),

  v_part - pmint(kernel, x)
)$

/* End of Gaussian/erf support functions */
